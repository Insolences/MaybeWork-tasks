const {} = require('./array_lib')

describe('Array functions QA', () => {
    test('1. Функция, которая берет массив объектов и возвращает массив значений определенного поля', () => {
        expect([{ 'name': 'tony', 'age': 20 }, { 'name': 'feel', 'age': 30 }].pluck('name')).toEqual(['tony', 'feel']);
    } )
    test('3. Функция, которая принимает на входе массив и число, обозначающее размер группы, на которые нужно разделить исходный массив', () => {
        expect(['a', 'b', 'c', 'd', 'e', 'f'].splitArray(2)).toEqual([['a', 'b'], ['c', 'd'], ['e', 'f']]);
    } )
    test('4. Функция, которая удалит из массива все "отрицательные" типы данных (false, null, 0, item !== 0, undefined, NaN)', () => {
        expect([1, 0, 2, false, '', 3].clearArray()).toEqual([1, 2, 3]);
    } )
    test('5. Функция, которая конкатенирует исходный массив с другими массивами или примитивными значениями', () => {
        expect([1].concatArray(2, [3], [[4]])).toEqual([1, 2, 3, [4]]);
    } )
    test('6. Функция, которая удалит указанное кол-во элементов с начала исходного массива', () => {
        expect([1, 2, 3].rm()).toEqual([2, 3]);
        expect([1, 2, 3].rm(2)).toEqual([3]);
        expect([1, 2, 3].rm(5)).toEqual([]);
        expect([1, 2, 3].rm(0)).toEqual([1, 2, 3]);
    });
    test('8. Функция, которая принимает массив, символ для замены,\n' +
        '// с какой ячейки начинать заменять и на какой остановиться. Если номера ячеек не заданы,\n' +
        '// то по умолчанию это начало и конец всего массива', () => {
        expect([1, 2, 3].replaceIn('a')).toEqual(['a', 'a', 'a']);
        expect([1, 2, 3].replaceIn(2)).toEqual([2, 2, 2]);
        expect([4, 6, 8, 10].replaceIn('*', 1, 3)).toEqual([4, '*', '*', 10]);
    } )
    test('10. Функция, которая вернет массив с всеми значениями, которые повторяются в исходном массиве', () => {
        expect([1,2,3,4,2,5,6,1,3].uni()).toEqual([1,2,3]);
    } )
    test('11. Функция, которая вернет элемент из массива по указанному индексу.\n' +
        '// Но если индекс отрицательный, то считаем с конца массива', () => {
        expect(['a', 'b', 'c', 'd'].nfa(1)).toEqual('b');
        expect(['a', 'b', 'c', 'd'].nfa(-2)).toEqual('c');
    } )
    test('13. Функция, которая принимает на входе массив и число, обозначающее размер группы, на которые нужно разделить исходный массив', () => {
        expect([].group(['a', 'b'], [1, 2], [true, false])).toEqual([['a', 1, true], ['b', 2, false]]);
    } )
    test('14. Функция, которая преобразует массив в строку через указанный разделитель', () => {
        expect(['a','b','c'].implode('-')).toEqual('a-b-c');
    } )
    test('17. Функция, которая перемешает массив в случайном порядке', () => {
        expect([1,2,3,4,5,6].rnd()).not.toEqual([1,2,3,4,5,6]);
    } )
    test('18. Напишите функцию, которая вернет разницу двух массивов\n' +
        '// (т.е. элементы, которых нет в исходных массивах)', () => {
        expect([1, 2, 'a'].diff([1, 2, 3, 4, 'b'])).toEqual(['a',3,4,'b']);
    } )
    test('20. Функция, которая вернет самый частый элемент массива', () => {
        expect([7, 'z', 'z', 'z', 3, 7, 'z', 7, 'z', 3, 5, 9, 7].fn()).toEqual('z');
    } )
});
